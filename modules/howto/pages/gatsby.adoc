= Using Neo4j With Gatsby.js
:slug: gatsby
:author: William Lyon
:category: labs
:tags: graphql, javascript, web
:neo4j-versions: 3.5, 4.0, 4.1, 4.2

Gatsby.js is a static site generator that uses React and GraphQL to create web pages.


== What Is Gatsby.js?

link:https://www.gatsbyjs.com/[Gatsby.js] is a JavaScript React-based framework for building web sites. Gatsby uses GraphQL as a data source for providing content from multiple sources during the build process to generate pre-rendered static web pages. A number of plugins are available for Gatsby that add additional features, functionality, and styling options. Gatsby is a popular tool that aligns with the Jamstack philosophy of pre-rendering web pages which are then served from a CDN and decoupling the services necessary to operate the site.

== Why Use Gatsby With Neo4j?

There are two fundamental approaches to using Gatsby with 

== Architecture Overview

image::gatsby.png[]

There are two ways to use GraphQL with Neo4j and Gatsby:

1. As a source for static content during Gatsby's build process
2. By querying the Neo4j GraphQL API from the client application - client runtime data fetching.

== How To Guide

In this example, we will use Gatsby and Neo4j to build a travel guide web application. The Gatsby build process will use data from Neo4j (a point of interest dataset extracted from OpenStreetMap) to create a page for each point of interest. We will also demonstrate how to make use of client runtime data fetching with Gatsby and Neo4j for routing, using pathfinding graph algorithms in Neo4j to find a route between points of interest.

=== Libraries / Packages 

The following libraries and packages are useful when using Neo4j and Gatsby.js together:

* link:https://grandstack.io/docs/neo4j-graphql-js[`neo4j-graphql-js`] - A package for building GraphQL APIs backed by Neo4j. GraphQL then becomes the integration point for Neo4j and Gatsby.
* link:https://www.gatsbyjs.com/plugins/gatsby-source-graphql/[`gatsby-source-graphql`] - A Gatsby plugin for stitching remote GraphQL schemas into the Gatsby GraphQL API.
* link:https://www.gatsbyjs.com/plugins/gatsby-plugin-apollo/[`gatsby-plugin-apollo`] - A Gatsby plugin to enable using Apollo Client for making client runtime GraphQL queries.

=== Sample Code

We will cover two ways of using Neo4j with Gatsby.js in this example. First, fetching data from Neo4j via a GraphQL API during the Gatsby build process. Next, we see how to use Neo4j to find routes between points of interest using client runtime data fetching queries.

This example uses the OpenStreetMap Neo4j Sandbox dataset and a GraphQL API exposing this data. We will not cover the process to create the GraphQL API as there are link:https://neo4j.com/developer/graphql/[other resources that cover using GraphQL with Neo4j], but the code for the GraphQL API can be found link:https://github.com/johnymontana/central-perk/tree/master/neo4j-graphql[on Github.]

==== Using Neo4j In The Gatsby Build Process

The Gatsby build process uses a GraphQL API as a content source for fetching data to be included in pre-rendered pages. We will use the link:https://www.gatsbyjs.com/plugins/gatsby-source-graphql/[`gatsby-source-graphql` plugin] to connect the Neo4j GraphQL to Gatsby's GraphQL API. Our "remote" schema will be stitched into the Gatsby GraphQL API and can be queried using Gatsby static or page queries during the build process.

Assuming you have already created a Gatsby project, install the `gatsby-source-graphql` plugin:

[source,shell]
----
$ npm install gatsby-source-graphql
----

Next, configure the `gatsby-source-graphql` plugin in `gatsby-config.js`, by specifying the url for the Neo4j GraphQL API, declaring an arbitrary type name that will wrap the remote schema Query type (`typeName`), and specifying a field under which the remote schema will be available in the Gatsby GraphQL API.

[source,js]
----
// gatsby-config.js

plugins: [
    {
        resolve: `gatsby-source-graphql`,
        options: {
            typeName: `PointOfInterest`,
            fieldName: `poi`,
            url: `http://localhost:3003`
        }
    },
... ]
----

After restarting the Gatsby server the remote GraphQL schema exposing data in Neo4j will be available to query in the Gatsby GraphQL API under the `poi` Query field and can be queried in Gatsby components using static or page queries. For example, here we query for the details for an individual point of interest to render the page for that point of interest.

[source,js]
----
// blog-post.js

const BlogPostTemplate = ({ data, pageContext, location }) => {
  const post = data.poi.PointOfInterest[0]
  const siteTitle = data.site.siteMetadata.title
  const { previous, next } = pageContext


  return (
    <Layout location={location} title={siteTitle}>
      <SEO title={post.name} description={post.type} />
      <article>
        <header>
          <h1
            style={{
              marginTop: rhythm(1),
              marginBottom: 0,
            }}
          >
            {post.name}
          </h1>
          <img src={post.photos[0]} alt={`Photo of ${post.name}`} />
          <p
            style={{
              ...scale(-1 / 5),
              display: `block`,
              marginBottom: rhythm(1),
            }}
          >
            {post.node_osm_id}
          </p>
        </header>
        <p>
          <ul>
            {post.tags?.map((t, i) => {
              return (
                <li key={i}>
                  <strong>{t.key}</strong>: {t.value}
                </li>
              )
            })}
          </ul>
        </p>
        <div dangerouslySetInnerHTML={{ __html: post.wikipedia }} />
        <hr
          style={{
            marginBottom: rhythm(1),
          }}
        />
        <footer>
          <Bio />
        </footer>
      </article>

      <nav>
        <ul
          style={{
            display: `flex`,
            flexWrap: `wrap`,
            justifyContent: `space-between`,
            listStyle: `none`,
            padding: 0,
          }}
        >
          <li>
            {previous && (
              <Link to={`/` + previous.node_osm_id} rel="prev">
                ← {previous.name}
              </Link>
            )}
          </li>
          <li>
            {next && (
              <Link to={`/` + next.node_osm_id} rel="next">
                {next.name} →
              </Link>
            )}
          </li>
        </ul>
      </nav>
    </Layout>
  )
}

export default BlogPostTemplate

export const pageQuery = graphql`
  query POIBySlug($slug: ID!) {
    site {
      siteMetadata {
        title
      }
    }
    allPOIs: poi {
      PointOfInterest(orderBy: name_asc) {
        name
        node_osm_id
      }
    }
    poi {
      PointOfInterest(node_osm_id: $slug) {
        name
        node_osm_id
        photos(first: 1)
        wikipedia
        location {
          latitude
          longitude
        }
        tags {
          key
          value
        }
        type
      }
    }
  }
`
----

By exporting a `pageQuery` GraphQL query Gatsby will execute this query at build time when rendering using this template. The results of this GraphQL query will then be passed to the React component in the `data` prop and the data can be used to render the page.

==== Client Runtime Data Fetching

Another way to use Gatsby.js with Neo4j is by querying Neo4j at runtime instead of build time. This can be done using the JavaScript Neo4j driver, the useNeo4j React hook, or via GraphQL. In this example we will configure the `gatsby-plugin-apollo` plugin and make use of the GraphQL client Apollo Client to execute GraphQL queries at run time.

First, install Apollo Client and the `gatsby-plugin-apollo` packages.

[source,shell]
----
$ npm install gatsby-plugin-apollo @apollo/client
----

Next, configure the `gatsby-plugin-apollo` in `gatsby-config.js` by specifying the uri of the GraphQL endpoint.

[source,js]
----
// gatsby-config.js
module.exports = {
  plugins: [
    {
      resolve: 'gatsby-plugin-apollo',
      options: {
        uri: 'http://localhost:3003'
      }
    }
  ]
};
----

An Apollo Client instance will be instantiated and injected into the React component hierarchy, making Apollo Client available in any React component in the Gatsby site.

Here we update the component for rendering point of interest detail information to include a map and route the user to their next selected point of interest. The route details are queried at runtime when the user selects a destination and are calculated using Neo4j's graph algorithm functionality (in this case the A* algorithm from the Graph Data Science library).

[source,js]
----
import { useLazyQuery, gql } from "@apollo/client"

const GET_ROUTE_QUERY = gql`
  query getRoute($from: ID!, $to: ID!) {
    PointOfInterest(node_osm_id: $from) {
      routeToPOI(poi: $to) {
        latitude
        longitude
      }
    }
  }
`

const BlogPostTemplate = ({ data, pageContext, location }) => {
  const post = data.poi.PointOfInterest[0]
  const siteTitle = data.site.siteMetadata.title
  const { previous, next } = pageContext

  const [getRoute, { loading, data: routeData }] = useLazyQuery(GET_ROUTE_QUERY)

  const [viewport, setViewport] = useState({
    latitude: 40.7812,
    longitude: -73.9665,
    zoom: 13,
  })

  const onRouteSelected = e => {
    // query the neo4j graphql API
    // to find optimal route from the current POI to the selected
    getRoute({ variables: { from: post.node_osm_id, to: e.target.value } })
  }

  let routeGeojson
  if (routeData) {
    routeGeojson = {
      type: "Feature",
      geometry: {
        type: "LineString",
        coordinates: routeData.PointOfInterest[0].routeToPOI.map((s, i) => {
          return [s.longitude, s.latitude]
        }),
      },
    }
  }

  return (
    <Layout location={location} title={siteTitle}>
      <SEO title={post.name} description={post.type} />
      <article>
        <header>
          <h1
            style={{
              marginTop: rhythm(1),
              marginBottom: 0,
            }}
          >
            {post.name}
          </h1>
          <img src={post.photos[0]} alt={`Photo of ${post.name}`} />
          Route to:
          <select name="route" onChange={onRouteSelected}>
            {data.allPOIs.PointOfInterest.map((p, i) => {
              return (
                <option key={i} value={p.node_osm_id}>
                  {p.name}
                </option>
              )
            })}
          </select>
          <MapGL
            style={{ width: "100%", height: "600px" }}
            mapStyle="mapbox://styles/mapbox/light-v9"
            accessToken={process.env.GATSBY_MAPBOX_KEY}
            latitude={viewport.latitude}
            longitude={viewport.longitude}
            zoom={viewport.zoom}
            onViewportChange={setViewport}
          >
            <Marker
              longitude={post.location.longitude}
              latitude={post.location.latitude}
            >
              <svg
                height={20}
                viewBox="0 0 24 24"
                style={{
                  cursor: "pointer",
                  fill: "green",
                  stroke: "none",
                }}
              >
                <path
                  d="M20.2,15.7L20.2,15.7c1.1-1.6,1.8-3.6,1.8-5.7c0-5.6-4.5-10-10-10S2,4.5,2,10c0,2,0.6,3.9,1.6,5.4c0,0.1,0.1,0.2,0.2,0.3
  c0,0,0.1,0.1,0.1,0.2c0.2,0.3,0.4,0.6,0.7,0.9c2.6,3.1,7.4,7.6,7.4,7.6s4.8-4.5,7.4-7.5c0.2-0.3,0.5-0.6,0.7-0.9
  C20.1,15.8,20.2,15.8,20.2,15.7z"
                />
              </svg>
            </Marker>
            {routeGeojson && (
              <div>
                <Source id="route" type="geojson" data={routeGeojson} />
                <Layer
                  id="route"
                  type="line"
                  source="route"
                  layout={{
                    "line-join": "round",
                    "line-cap": "round",
                  }}
                  paint={{
                    "line-color": "blue",
                    "line-width": 8,
                  }}
                />
                <Marker
                  longitude={
                    routeGeojson.geometry.coordinates[
                      routeGeojson.geometry.coordinates.length - 1
                    ][0]
                  }
                  latitude={
                    routeGeojson.geometry.coordinates[
                      routeGeojson.geometry.coordinates.length - 1
                    ][1]
                  }
                >
                  <svg
                    height={20}
                    viewBox="0 0 24 24"
                    style={{
                      cursor: "pointer",
                      fill: "red",
                      stroke: "none",
                    }}
                  >
                    <path
                      d="M20.2,15.7L20.2,15.7c1.1-1.6,1.8-3.6,1.8-5.7c0-5.6-4.5-10-10-10S2,4.5,2,10c0,2,0.6,3.9,1.6,5.4c0,0.1,0.1,0.2,0.2,0.3
  c0,0,0.1,0.1,0.1,0.2c0.2,0.3,0.4,0.6,0.7,0.9c2.6,3.1,7.4,7.6,7.4,7.6s4.8-4.5,7.4-7.5c0.2-0.3,0.5-0.6,0.7-0.9
  C20.1,15.8,20.2,15.8,20.2,15.7z"
                    />
                  </svg>
                </Marker>
              </div>
            )}
          </MapGL>
       ...

    </Layout>
  )
}
----

== Resources

// * link:https://grandstack.io[Neo4j GraphQL documentation]
// * link:https://github.com/johnymontana/central-perk[Gatsby.js / Neo4j GraphQL travel guide demo app]

[cols="1,4"]
|===
// | icon:comments[] Support | https://community.neo4j.com/c/drivers-stacks/graphql-grandstack[Neo4j Online Community]
// | icon:user[] Authors | William Lyon, Michael Graham
| icon:book[] Neo4j GraphQL documentation | https://grandstack.io
// | icon:gift[] Releases | https://github.com/neo4j-graphql/neo4j-graphql-js/releases
| icon:github[] Gatsby.js / Neo4j GraphQL travel guide demo app | https://github.com/neo4j-graphql/neo4j-graphql-js
// | icon:book[] Docs | https://grandstack.io/docs
// | icon:book[] Article |
// | icon:play-circle[] Example | https://grandstack.io/docs/getting-started-grand-stack-starter.html[The GRANDstack starter]
// | icon:rss[] Blog | https://blog.grandstack.io
|===

== Videos & Tutorials

=== Building A Travel Guide With Gatsby, Neo4j, & GraphQL

This six part video tutorial goes through the steps of building a travel guide web application taking advantage of both static page rendering with Gatsby.js and client runtime data fetching.

==== Part 1: Getting Started with Neo4j, Gatsby, and GraphQL

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/siPmZRTRki8' frameborder='0' allowfullscreen></iframe></div>
++++

==== Part 2: Using GraphQL With Gatsby.js

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/XCuknJAIX84' frameborder='0' allowfullscreen></iframe></div>
++++

==== Part 3: Images & Wikipedia Data With GraphQL

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/_DBVYEgr73E' frameborder='0' allowfullscreen></iframe></div>
++++

==== Part 4: Routing With Graph Algorithms

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/MvjhSDsai9U' frameborder='0' allowfullscreen></iframe></div>
++++

==== Part 5: DigitalOcean App Platform Deployment

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/SIDwj4mfbVQ' frameborder='0' allowfullscreen></iframe></div>
++++

===== Part 6: Maps & Routes With Mapbox GL JS

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/6eRzgpMOG9A' frameborder='0' allowfullscreen></iframe></div>
++++
