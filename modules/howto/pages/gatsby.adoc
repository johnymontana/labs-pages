= Using Neo4j With Gatsby.js
:slug: gatsby
:author: William Lyon
:category: labs
:tags: graphql, javascript, web
:neo4j-versions: 3.5, 4.0, 4.1, 4.2

Gatsby.js is a static site generator that uses React and GraphQL to create web pages.


== What Is Gatsby.js?

link:https://www.gatsbyjs.com/[Gatsby.js] is a JavaScript React-based framework for building web sites. Gatsby uses GraphQL as a data source for providing content from multiple sources during the build process to generate pre-rendered static web pages. A number of plugins are available for Gatsby that add additional features, functionality, and styling options. Gatsby is a popular tool that aligns with the Jamstack philosophy of pre-rendering web pages which are then served from a CDN and decoupling the services necessary to operate the site.

== Why Use Gatsby With Neo4j?

There are two fundamental approaches to using Gatsby with 

== Architecture Overview

image::gatsby.png[]

There are two ways to use GraphQL with Neo4j and Gatsby:

1. As a source for static content during Gatsby's build process
2. By querying the Neo4j GraphQL API from the client application - client runtime data fetching.

== How To Guide

In this example, we will use Gatsby and Neo4j to build a travel guide web application. The Gatsby build process will use data from Neo4j (a point of interest dataset extracted from OpenStreetMap) to create a page for each point of interest. We will also demonstrate how to make use of client runtime data fetching with Gatsby and Neo4j for routing, using pathfinding graph algorithms in Neo4j to find a route between points of interest.

=== Libraries / Packages 

* `neo4j-graphql-js`
* `gatsby-source-graphql`
* ``

=== Sample Code

We will cover two ways of using Neo4j with Gatsby.js in this example. First, fetching data from Neo4j via a GraphQL API during the Gatsby build process. Next, we see how to use Neo4j to find routes between points of interest using client runtime data fetching queries.

This example uses the OpenStreetMap Neo4j Sandbox dataset and a GraphQL API exposing this data. We will not cover the process to create the GraphQL API as there are link:https://neo4j.com/developer/graphql/[other resources that cover using GraphQL with Neo4j], but the code for the GraphQL API can be found link:https://github.com/johnymontana/central-perk/tree/master/neo4j-graphql[on Github.]

==== Using Neo4j In The Gatsby Build Process

The Gatsby build process uses a GraphQL API as a content source for fetching data to be included in pre-rendered pages. We will use the link:https://www.gatsbyjs.com/plugins/gatsby-source-graphql/[`gatsby-source-graphql` plugin] to connect the Neo4j GraphQL to Gatsby's GraphQL API. Our "remote" schema will be stitched into the Gatsby GraphQL API and can be queried using Gatsby static or page queries during the build process.

Assuming you have already created a Gatsby project, install the `gatsby-source-graphql` plugin:

[source,shell]
----
npm install gatsby-source-graphql
----

Next, configure the `gatsby-source-graphql` plugin in `gatsby-config.js`, by specifying the url for the Neo4j GraphQL API, declaring an arbitrary type name that will wrap the remote schema Query type (`typeName`), and specifying a field under which the remote schema will be available in the Gatsby GraphQL API.

[source,js]
----
// gatsby-config.js

plugins: [
    {
        resolve: `gatsby-source-graphql`,
        options: {
            typeName: `PointOfInterest`,
            fieldName: `poi`,
            url: `http://localhost:3003`
        }
    },
... ]
----

After restarting the Gatsby server the remote GraphQL schema exposing data in Neo4j will be available to query in the Gatsby GraphQL API under the `poi` Query field and can be queried in Gatsby components using static or page queries. For example, here we query for the details for an individual point of interest to render the page for that point of interest.

[source,js]
----
// blog-post.js

const BlogPostTemplate = ({ data, pageContext, location }) => {
  const post = data.poi.PointOfInterest[0]
  const siteTitle = data.site.siteMetadata.title
  const { previous, next } = pageContext


  return (
    <Layout location={location} title={siteTitle}>
      <SEO title={post.name} description={post.type} />
      <article>
        <header>
          <h1
            style={{
              marginTop: rhythm(1),
              marginBottom: 0,
            }}
          >
            {post.name}
          </h1>
          <img src={post.photos[0]} alt={`Photo of ${post.name}`} />
          <p
            style={{
              ...scale(-1 / 5),
              display: `block`,
              marginBottom: rhythm(1),
            }}
          >
            {post.node_osm_id}
          </p>
        </header>
        <p>
          <ul>
            {post.tags?.map((t, i) => {
              return (
                <li key={i}>
                  <strong>{t.key}</strong>: {t.value}
                </li>
              )
            })}
          </ul>
        </p>
        <div dangerouslySetInnerHTML={{ __html: post.wikipedia }} />
        <hr
          style={{
            marginBottom: rhythm(1),
          }}
        />
        <footer>
          <Bio />
        </footer>
      </article>

      <nav>
        <ul
          style={{
            display: `flex`,
            flexWrap: `wrap`,
            justifyContent: `space-between`,
            listStyle: `none`,
            padding: 0,
          }}
        >
          <li>
            {previous && (
              <Link to={`/` + previous.node_osm_id} rel="prev">
                ← {previous.name}
              </Link>
            )}
          </li>
          <li>
            {next && (
              <Link to={`/` + next.node_osm_id} rel="next">
                {next.name} →
              </Link>
            )}
          </li>
        </ul>
      </nav>
    </Layout>
  )
}

export default BlogPostTemplate

export const pageQuery = graphql`
  query POIBySlug($slug: ID!) {
    site {
      siteMetadata {
        title
      }
    }
    allPOIs: poi {
      PointOfInterest(orderBy: name_asc) {
        name
        node_osm_id
      }
    }
    poi {
      PointOfInterest(node_osm_id: $slug) {
        name
        node_osm_id
        photos(first: 1)
        wikipedia
        location {
          latitude
          longitude
        }
        tags {
          key
          value
        }
        type
      }
    }
  }
`
----

==== Client Runtime Data Fetching

Another way to use Gatsby.js with Neo4j is by querying Neo4j at runtime instead of build time. This can be done using the JavaScript Neo4j driver or the useNeo4j React hook

== Resources

// * link:https://grandstack.io[Neo4j GraphQL documentation]
// * link:https://github.com/johnymontana/central-perk[Gatsby.js / Neo4j GraphQL travel guide demo app]

[cols="1,4"]
|===
// | icon:comments[] Support | https://community.neo4j.com/c/drivers-stacks/graphql-grandstack[Neo4j Online Community]
// | icon:user[] Authors | William Lyon, Michael Graham
| icon:book[] Neo4j GraphQL documentation | https://grandstack.io
// | icon:gift[] Releases | https://github.com/neo4j-graphql/neo4j-graphql-js/releases
| icon:github[] Gatsby.js / Neo4j GraphQL travel guide demo app | https://github.com/neo4j-graphql/neo4j-graphql-js
// | icon:book[] Docs | https://grandstack.io/docs
// | icon:book[] Article |
// | icon:play-circle[] Example | https://grandstack.io/docs/getting-started-grand-stack-starter.html[The GRANDstack starter]
// | icon:rss[] Blog | https://blog.grandstack.io
|===

== Videos & Tutorials

=== Building A Travel Guide With Gatsby, Neo4j, & GraphQL

This six part video tutorial goes through the steps of building a travel guide web application taking advantage of both static page rendering with Gatsby.js and client runtime datafetching.

==== Part 1: Getting Started with Neo4j, Gatsby, and GraphQL

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/siPmZRTRki8' frameborder='0' allowfullscreen></iframe></div>
++++

==== Part 2: Using GraphQL With Gatsby.js

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/XCuknJAIX84' frameborder='0' allowfullscreen></iframe></div>
++++

==== Part 3: Images & Wikipedia Data With GraphQL

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/_DBVYEgr73E' frameborder='0' allowfullscreen></iframe></div>
++++

==== Part 4: Routing With Graph Algorithms

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/MvjhSDsai9U' frameborder='0' allowfullscreen></iframe></div>
++++

==== Part 5: DigitalOcean App Platform Deployment

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/SIDwj4mfbVQ' frameborder='0' allowfullscreen></iframe></div>
++++

===== Part 6: Maps & Routes With Mapbox GL JS

++++
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/6eRzgpMOG9A' frameborder='0' allowfullscreen></iframe></div>
++++
