= Using Neo4j With GraalVM
:docs: 
:slug: graalvm
:author: Jennifer Reif
:category: labs
:tags: jvm, polyglot, programming, drivers
:neo4j-versions: 3.5, 4.0, 4.1, 4.2

GraalVM is a runtime that seeks to improve application performance and efficiency, as well as offer a shared runtime for different programming languages to interact with each other.

== What Is GraalVM?

It is a Java Virtual Machine (JVM) and Java Development Kit (JDK) bundled together to decrease the footprint and startup time of an application. GraalVM includes a just-in-time (JIT) compiler, native image, Truffle language implementation framework, and built-in tools. Each of these provisions is explained in a bit more detail below.

* JIT compiler: written in Java and intended to be more modular and flexible than previous compilers. Can run alongside existing compilers, as well as run instead of others.
* https://www.graalvm.org/reference-manual/native-image/[GraalVM native image^]: ahead-of-time (AOT) compiler for JVM-based languages or those implemented in Truffle. Compiles these to executable binaries with the goal of minimal application startup time and application file size.
* https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/[Truffle Language Implementation Framework^]: for implementing additional languages on GraalVM. Current implementations include Javascript, Python, Ruby, R, and LLVM. Other language interpreters can be added by using Truffle as the foundation framework.
* https://www.graalvm.org/docs/tools/[Out-of-the-box tools^]: for monitoring, debugging, and development. GraalVM contains language-agnostic tools like backend and Chrome debuggers, dashboards, profiling, code coverage, VSCode extensions, and language protocols.

== Why Use GraalVM With Neo4j?

There are a few different reasons why developers might choose GraalVM over other JVM options.

1. To access Neo4j from outside languages using an official driver (like the Java driver). This allows you to use the Java libraries for connecting to Neo4j from languages like Python, Ruby, R, Javascript, LLVM, as well as other language implementations built with Truffle.

2. To write programs in various languages and bring in non-Java libraries to use with it.
For instance, you could pull in Python's `ratelimit` library or Javascript's `colors` into any other language for a program interacting with Neo4j.

3. To extend Neo4j or the Cypher query language by writing procedures and functions in any language and packaging them as a database plugin for Neo4j.

4. To use Cypher as the query language in various programs (with Cypher Truffle implementation). This would allow you to embed Cypher code in your Python or Javascript program for executing against Neo4j.

== Architecture Overview

image::graalvm_neo4j.png[]

Currently, there are two ways to use GraalVM with Neo4j:

1. Connect to and interact with Neo4j (using the official Java driver) from non-JVM languages - Python, Ruby, R, and Javascript.
2. Execute code in Python, Ruby, R, and Javascript like a Cypher procedure (deployed in a Neo4j plugin).

== How To

=== Libraries / Packages 

* `graalvm/graalvm-ce-builds` - https://github.com/graalvm/graalvm-ce-builds/releases[releases for download^]

Others needed:

1. Connect to Neo4j from non-JVM languages:
* `neo4j-java-driver` - https://neo4j.com/download-center/#drivers[Neo4j Drivers download page^]
* `reactive-streams` - dependency of Java driver above (https://neo4j.com/docs/java-manual/4.2/get-started/#java-driver-get-started-installation[Java driver manual, dependencies^])

2. Execute custom procedures/functions:
* `neo4j` - https://neo4j.com/download-center/#community[download Neo4j community server^]

=== Sample Code

We will cover a very basic example for connecting to Neo4j from various languages and a Neo4j extension. For both use cases, we will need GraalVM and Neo4j. The steps for setting those up are listed below.

* Download and install GraalVM SDK.

There are a variety of ways to do this (https://www.graalvm.org/docs/getting-started/#install-graalvm[GraalVM docs^]), but I used https://sdkman.io/[SDKMAN!^] to install and set it as my default SDK. SDKMAN takes care of the path management of finding and using the SDK. Instructions and helpful commands are shown in https://blog.codeleak.pl/2020/01/manage-multiple-java-sdks-with-sdkman.html#manage-java-versions[this blog post^].

* Install any GraalVM languages you intend to use with the https://www.graalvm.org/reference-manual/graalvm-updater/#component-installation[GraalVM Updater^] (gu).
- Python (GraalPython): use command `gu install python` (shown in https://www.graalvm.org/docs/getting-started/#run-python[docs^]). You can then use the `graalpython` command to execute .py scripts.
- Javascript (Graal.js): no install needed. Graal.js comes bundled with GraalVM (shown in https://www.graalvm.org/docs/getting-started/#run-javascript-and-nodejs[docs^]). You can verify this by running `gu list` and seeing the js item in the list. You can use the `js` or `node` commands to execute .js scripts.
- R (FastR): use command `gu install R` (shown in https://www.graalvm.org/docs/getting-started/#run-r[docs^]). Then you can use the `Rscript` command to run .r files.
- Ruby (TruffleRuby): use command `gu install ruby` (shown in https://www.graalvm.org/docs/getting-started/#run-ruby[docs^]). To run .rb scripts, you can use the `truffleruby` command.
- C/C++ (LLVM): use command `gu install llvm-toolchain` (shown in https://www.graalvm.org/docs/getting-started/#run-llvm-languages[docs^]). Then you can run .c files with the `lli` command.
- WebAssembly (web C): use command `gu install wasm` (shown in https://www.graalvm.org/docs/getting-started/#run-webassembly[docs^]). You can then compile .c programs to .wasm files and execute using the `wasm` command.

* Create and start an instance of Neo4j.

You can do this with https://neo4j.com/download-center/#desktop[Neo4j Desktop^], https://sandbox.neo4j.com/[Sandbox^], or https://neo4j.com/download-center/#community[community server^] for free.

For Desktop or server, you will need to start a database (sandbox handles this for you). Instructions for this in Desktop are provided in a https://neo4j.com/developer/neo4j-desktop/#desktop-create-graph[developer guide^]. Instructions for server are shown after the download begins, but you should be able to navigate to the directory where it was downloaded, unzip it, and run `bin/neo4j start` to spin up the database.

=== Sample Code #1

In this example, we will connect to Neo4j from Python with the Java driver, query the database, and return results.

While we can create a Maven/Gradle project, this example will start even more simply.

1. Download Java driver and reactive stream dependency. Maven download links are as follows:
- https://search.maven.org/remotecontent?filepath=org/neo4j/driver/neo4j-java-driver/4.0.3/neo4j-java-driver-4.0.3.jar[Java driver 4.0.3^]
- https://search.maven.org/remotecontent?filepath=org/reactivestreams/reactive-streams/1.0.3/reactive-streams-1.0.3.jar[Reactive streams 1.0.3^]

2. In a folder of your preference, copy the dependency jars from the step above. Then create a file called `graalvm-test.py` in that same folder. Note: you can choose Javascript, Ruby, R, or LLVM instead of Python, as well.

3. Copy the below code into the program (`graalvm-test.py`) and then change the password on the `authTokens.basic('neo4j', 'Testing123')` line to be the password you set for your database. Note: If using Neo4j Sandbox, you will also need to modify the line above the authTokens with the sandbox connection BOLT URL.

[source,python]
----
import java

# Add Java libraries to GraalVM from Python
java.add_to_classpath("reactive-streams-1.0.3.jar")
java.add_to_classpath("neo4j-java-driver-4.0.3.jar")

# Bring in required classes
graphDatabase = java.type('org.neo4j.driver.GraphDatabase')
authTokens = java.type('org.neo4j.driver.AuthTokens')
config = java.type('org.neo4j.driver.Config')
sessionConfig = java.type('org.neo4j.driver.SessionConfig')

# Call static factory method named `driver`
driver = graphDatabase.driver(
    'bolt://localhost:7687',
    authTokens.basic('neo4j', 'Testing123'),
    config.builder()
        .withMaxConnectionPoolSize(1) # Don't need a bigger pool size for a script
        .build()
)

# Use Neo4j's Values to build parameters (Python dicts not converted to Java maps)
values = java.type('org.neo4j.driver.Values')

def findConnections(driver):
    query = """
        MATCH (:Person {name:$name})-[:ACTED_IN]->(movie)
        RETURN DISTINCT movie
    """

    session = driver.session(sessionConfig.forDatabase("neo4j"))
    records = session.run(query, values.parameters("name", "Tom Hanks")).list()

    movies = [r.get('movie').get('title').asString() for r in records]

    session.close()
    return movies

results = findConnections(driver)

for title in results:
    print(title)

driver.close()
----

4. Save and close the program, then run it using the command below.

[source,shell]
----
graalpython --jvm graalvm-test.py
----

=== Sample Code #2

In this example, we will write a custom procedure that we can call with Cypher.

Due to a built-in environment in Neo4j Desktop, we recommend using Neo4j community server for this example.

1. In a folder of your preference, clone the polyglot repository and open it with your favorite IDE (like https://www.jetbrains.com/idea/[IntelliJ IDEA^]).

2. Run a `mvn clean package` on the project (either at command line or through your IDE). This will create a .jar file in the `target` folder.

3. Copy the .jar file (in this case, named `neo4j-graalvm-polyglot-1.0-SNAPSHOT.jar`) to the `plugins` directory where the Neo4j community server is installed. If the Neo4j database is currently running, do a `bin/neo4j restart` in the Neo4j folder.

4. Open Neo4j Browser by going to a web browser and typing in `localhost:7474` (if using sandbox, this won't work as it's not on localhost). It may ask you to log in with the credentials you used to set up the database.

5. Then, we can call this procedure from Cypher shell or Neo4j Browser as shown below.

[source,cypher]
----
CALL polyglot.run(
    'python',
    'import math; totalEntities = 3000; callsNeeded = int(math.ceil(totalEntities / 100)); callsNeeded'
);
----

== Resources

[cols="1,4"]
|===
| icon:github[] Connect to Neo4j from GraalVM | https://github.com/neo4j-labs/neo4j-graalvm
| icon:github[] Extend Neo4j with GraalVM | https://github.com/neo4j-labs/neo4j-graalvm-polyglot
| icon:book[] GraalVM Docs | https://www.graalvm.org/docs/introduction/
| icon:book[] Neo4j docs | https://neo4j.com/docs/
// | icon:book[] Article |
| icon:comments[] Feedback, Questions, & Requests | https://community.neo4j.com/[Neo4j Online Community]
|===